<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<!--
Material design: [Surface reaction](https://www.google.com/design/spec/animation/responsive-interaction.html#responsive-interaction-surface-reaction)
`paper-ripple` provides a visual effect that other paper elements can
use to simulate a rippling effect emanating from the point of contact.  The
effect can be visualized as a concentric circle with motion.
Example:
    <div style="position:relative;">
      <paper-ripple></paper-ripple>
    </div>
Note, it's important that the parent container of the ripple be relative position, otherwise
the ripple will emanate outside of the desired container.
`paper-ripple` listens to "mousedown" and "mouseup" events so it would display ripple
effect when touches on it.  You can also defeat the default behavior and
manually route the down and up actions to the ripple element.  Note that it is
important if you call `downAction()` you will have to make sure to call
`upAction()` so that `paper-ripple` would end the animation loop.
Example:
    <paper-ripple id="ripple" style="pointer-events: none;"></paper-ripple>
    ...
    downAction: function(e) {
      this.$.ripple.downAction({detail: {x: e.x, y: e.y}});
    },
    upAction: function(e) {
      this.$.ripple.upAction();
    }
Styling ripple effect:
  Use CSS color property to style the ripple:
    paper-ripple {
      color: #4285f4;
    }
  Note that CSS color property is inherited so it is not required to set it on
  the `paper-ripple` element directly.
By default, the ripple is centered on the point of contact.

@group Paper Elements
@element paper-ripple
@hero hero.svg
@demo demo/index.html
-->
<dom-module id="paper-ripple">
  <template>
    <style>
      @keyframes ripple-fade-in-out {
        0% {
          opacity: 0.25;
        }
        10% {
          opacity: 0.25;
        }
        100% {
          opacity: 0;
        }
      }

      @keyframes ripple-expand {
        0% {
          transform: scale(0);
        }
        100% {
          transform: scale(1);
        }
      }

      :host {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        pointer-events: none;
        contain: strict;
      }

      #ripple {
        pointer-events: none;
        background-color: currentColor;
        will-change: transform, opacity;
        animation-duration: 0.3s;
        animation-timing-function: cubic-bezier(.157, .72, .386, .987), linear;
        border-radius: 50%;
        opacity: 0;
      }
    </style>
    <div id="ripple"></div>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-ripple',

    properties: {

      /* Legacy */
      recenters: {
        type: Boolean,
        value: false
      },
      /**
       * If true, ripples will center inside its container
       *
       * @attribute center
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },
      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       *
       * @type boolean
       * @default false
       */
      noink: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      }
    },

    attached: function() {
      /* Legacy */
      this._eventTarget = this.parentNode.nodeType == 11 ?
          Polymer.dom(this).getOwnerRoot().host : this.parentNode;
      this.listen(this._eventTarget, 'down', 'uiDownAction');
      this.listen(this._eventTarget, 'up', 'uiUpAction');
      this.listen(this._eventTarget, 'keydown', '_keydownHandler');
    },

    detached: function() {
      /* Legacy */
      this.unlisten(this._eventTarget, 'down', 'uiDownAction');
      this.unlisten(this._eventTarget, 'up', 'uiUpAction');
      this.unlisten(this._eventTarget, 'keydown', '_keydownHandler');
      this._eventTarget = null;
    },

    _showRipple: function(rect, holdDown, point) {
      if (!this._eventTarget) {
        return;
      }
      var centers = this.center || this.recenters,
          diameter = centers
            ? Math.max(rect.width, rect.height)
            : Math.sqrt(rect.width*rect.width + rect.height*rect.height) * 1.5,
          style = this.$.ripple.style,
          x = point.x - rect.left - diameter/2,
          y = point.y - rect.top - diameter/2;

      style.width = diameter + 'px';
      style.height = diameter + 'px';
      style.marginTop = y + 'px';
      style.marginLeft = x + 'px'

      if (holdDown) {
        style.opacity = 0.25;
        style.animationName = 'ripple-expand, none';
      } else {
        style.opacity = 0;
        style.animationName = 'ripple-expand, ripple-fade-in-out';
      }
    },

    _debounceRaf: function(fn) {
      this.$.ripple.style.animationName = '';
      cancelAnimationFrame(this._rafTask);
      this._rafTask = requestAnimationFrame(fn.bind(this));
    },

    _cleanUp: function() {
      var style = this.$.ripple.style;
      clearTimeout(this._cleanUpTask);
      this._cleanUpTask = setTimeout(function() {
        style.animationName = '';
        style.opacity = 0;
      }, 300);
    },

    /* Legacy */
    downAction: function(event) {
      this._downActionTimeStamp = event.timeStamp;
      this._debounceRaf(function() {
        var rect = this.getBoundingClientRect(),
            centers = this.center || this.recenters;
        this._showRipple(rect,
          centers || this.holdDown,
          centers
          ? {
              x: rect.left + rect.width/2,
              y: rect.top + rect.height/2
            }
          : event.detail
        );
      });
    },

    /* Legacy */
    upAction: function(event) {
      if (!this.holdDown && (this.center || this.recenters)) {
        var style = this.$.ripple.style,
            holdTime = event.timeStamp - this._downActionTimeStamp;
        style.animationName = holdTime > 300
          ? 'none, ripple-fade-in-out'
          : 'ripple-expand, ripple-fade-in-out';
        style.opacity = 0;
        this._cleanUp();
      }
    },

    /* Legacy */
    uiDownAction: function(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /* Legacy */
    uiUpAction: function(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    _centerRipple: function(holdDown) {
      this._debounceRaf(function() {
        var rect = this.getBoundingClientRect();
        this._showRipple(rect, holdDown, {
          x: rect.left + rect.width/2,
          y: rect.top + rect.height/2
        });
        this._cleanUp();
      });
    },

    /* Legacy */
    _keydownHandler: function(event) {
      if (event.keyCode == /* ENTER */ 13) {
        this._centerRipple(false);
      }
    },

    _holdDownChanged: function(holdDown, prevHoldDown) {
      if (holdDown) {
        this._centerRipple(true);
      } else if (prevHoldDown) {
        var style = this.$.ripple.style;
        style.animationName = 'none, ripple-fade-in-out';
        style.opacity = 0;
        this._cleanUp();
      }
    }
  });
</script>
